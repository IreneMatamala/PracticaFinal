name: Deploy to AKS

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  ACR_REGISTRY: techwaveacr123.azurecr.io
  CLUSTER_NAME: techwave-aks
  RESOURCE_GROUP: techwave-rg

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

  deploy-app:
    needs: test
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Kubernetes
      uses: azure/setup-kubectl@v3

    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Login to ACR
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.ACR_REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Connect to AKS
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ env.RESOURCE_GROUP }}
        cluster-name: ${{ env.CLUSTER_NAME }}

    - name: Deploy Application
      run: |
        echo "Desplegando aplicacion TechWave..."
        kubectl apply -f k8s/app/ -n techwave-app
        
        echo "Actualizando imagenes desde ACR..."
        kubectl set image deployment/frontend-deployment *=${ACR_REGISTRY}/frontend:latest -n techwave-app
        kubectl set image deployment/backend-deployment *=${ACR_REGISTRY}/backend:latest -n techwave-app
        
        echo "Esperando que la aplicacion este lista..."
        kubectl rollout status deployment/frontend-deployment -n techwave-app --timeout=300s
        kubectl rollout status deployment/backend-deployment -n techwave-app --timeout=300s
        
        echo "Aplicacion desplegada exitosamente"
        kubectl get all -n techwave-app

    - name: Test Application
      run: |
        echo "Probando aplicacion..."
        kubectl port-forward -n techwave-app service/frontend-service 8080:80 &
        sleep 10
        curl -f http://localhost:8080/ || echo "Frontend test failed"
        
        kubectl port-forward -n techwave-app service/backend-service 5000:5000 &
        sleep 5
        curl -f http://localhost:5000/health || echo "Backend test failed"

  setup-monitoring:
    needs: deploy-app
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Kubernetes
      uses: azure/setup-kubectl@v3

    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Login to ACR
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.ACR_REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Connect to AKS
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ env.RESOURCE_GROUP }}
        cluster-name: ${{ env.CLUSTER_NAME }}

    - name: Install Helm
      run: |
        echo "Instalando Helm..."
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        helm version

    - name: Install Monitoring Stack
      run: |
        echo "Configurando monitoreo..."
        
        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
        helm repo add grafana https://grafana.github.io/helm-charts
        helm repo update
        helm list -A
        
        if helm list -A | grep -q monitoring; then
            echo "Limpiando release monitoring existente..."
            helm uninstall monitoring -n monitoring 2>/dev/null || true
            sleep 10
        fi
        
        if kubectl get pods -n monitoring --no-headers 2>/dev/null | grep -q prometheus; then
            echo "Hay una instalacion previa de monitoring - eliminando..."
            kubectl delete namespace monitoring 2>/dev/null || true
            sleep 20
        fi
        
        echo "Instalando monitoring desde cero..."
        helm install monitoring prometheus-community/kube-prometheus-stack \
          --namespace monitoring \
          --create-namespace \
          --wait \
          --timeout 30m \
          --set prometheus.prometheusSpec.resources.requests.cpu=100m \
          --set prometheus.prometheusSpec.resources.requests.memory=256Mi \
          --set grafana.resources.requests.cpu=50m \
          --set grafana.resources.requests.memory=128Mi
        
        echo "Monitoring instalado exitosamente"
    
    - name: Install Loki
      run: |
        helm upgrade --install loki grafana/loki-stack \
          --namespace monitoring \
          --set loki.persistence.enabled=false \
          --set promtail.enabled=false \
          --set grafana.enabled=false \
          --wait \
          --timeout 15m
        
        echo "Loki instalado via Helm"

    - name: Install OpenTelemetry
      run: |
        echo "Instalando OpenTelemetry para trazas..."
        kubectl apply -f k8s/monitoring/open-telemetry.yaml -n monitoring --wait=true
        
        echo "Verificando instalacion de OpenTelemetry..."
        kubectl wait --for=condition=ready pod -l app=otel-collector -n monitoring --timeout=180s
   
    - name: Apply Monitoring Config
      run: |
        echo "Aplicando configuracion de monitoreo..."
        kubectl apply -f alerts-Monitoring/grafana-dashboard.yml -n monitoring
        
        if [ -f "alerts-Monitoring/prometheus-rules.yml" ]; then
            kubectl apply -f alerts-Monitoring/prometheus-rules.yml -n monitoring
        fi
        
        echo "Configuracion de monitoreo aplicada"

    - name: Verify Monitoring
      run: |
        echo "Verificando estado del monitoreo..."
        kubectl get pods -n monitoring
        
        echo "Esperando inicializacion..."
        sleep 60
        
        echo "Pods en estado Running:"
        kubectl get pods -n monitoring --field-selector=status.phase=Running --no-headers | wc -l
        
        echo "Monitoreo desplegado - verificacion basica completada"

    - name: Verify HPA Working
      run: |
        echo "Esperando métricas..."
        sleep 60
        echo "Estado del HPA:"
        kubectl get hpa -n techwave-app
        echo "Métricas de nodos:"
        kubectl top nodes
        
    - name: Final Health Check
      run: |
        echo "Verificacion final del sistema..."
        
        echo "Estado de la aplicacion:"
        kubectl get all -n techwave-app
        
        echo "Estado del monitoreo:"
        kubectl get all -n monitoring
        
        echo "Estado del cluster:"
        kubectl get nodes
        
        echo "Todos los servicios desplegados exitosamente"
